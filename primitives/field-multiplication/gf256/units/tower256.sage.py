

# This file was *autogenerated* from the file tower256.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_10 = Integer(10); _sage_const_32 = Integer(32)# We are working in fields of characteristic 2
# We will build a tower of field extension
#   using the Theorems 3.75 and 3.79 of "Finite Field"
#   of Lidl and Niederreiter.
# ==== Theorem 3.79 ====
# Let 'a' belongs to F_q and p the characteristic of F_q
# Then, the trinomial x^p - x - a is irreducible in F_q[X]
# if and only if the trace Tr_{F_q}(a) is not zero.
#   => In our case:
# Let 'a' belongs to F_{2^m}
# Then, the trinomial x^2 - x - a is irreducible in F_{2^m}[X]
# if and only if the trace Tr_{F_{2^m}}(a) is not zero.
# ==== Theorem 3.75 ====
# Let 'a' belongs to F_q^*
# Then, the binomial x^t - a is irreducible in F_q[X]
# if and only if
#   (1) each prime factor of t divides the order e of a in F_q^*, but not (q-1)/e
#   (2) q % 4 = 1 if t % 4 = 0
#   => In our case:
# t = 3, so (2) is always satisfied. (1) can also be simplify into
#   (1') 3 should not divide (q-1)/e where e is the order of a in F_q^*,
#         or equivalently, a^((q-1)/3) should not be equal to 1.

def is_valid(q_pow, a, div=_sage_const_2 ):
    return a**((q_pow-_sage_const_1 )//div) != _sage_const_1 

def from_integer_representation(F, v):
    r = F.gen()
    binary = list(map(int, bin(v)[_sage_const_2 :].rjust(F.degree(), '0')))
    binary.reverse()
    res = F(_sage_const_0 )
    for i, bit in enumerate(binary):
        if bit:
            res += (r**i)
    return res

def to_numerical(t):
    try:
        return t.integer_representation()
    except AttributeError:
        return [to_numerical(v) for v in list(t)]

def trace(v):
    F = v.parent()
    q = F.characteristic()
    m = round(log(F.order(),q))
    return sum(
        v**(q**(i))
        for i in range(m)
    )

# First step of the Tower
F2 = FiniteField(_sage_const_2 )
R_over_F2 = PolynomialRing(F2, names=('Y',)); (Y,) = R_over_F2._first_ngens(1)
#F2t8.<z8> = F2.extension(Y^8+Y^6+Y^3+Y^2+1, 'z8')
F2t8 = F2.extension(Y**_sage_const_8 +Y**_sage_const_4 +Y**_sage_const_3 +Y+_sage_const_1 , 'z8', names=('z8',)); (z8,) = F2t8._first_ngens(1)
R = PolynomialRing(F2t8, names=('X',)); (X,) = R._first_ngens(1)

# Step 2
a = z8**_sage_const_5 
p = X**_sage_const_2  + X + a
assert a.trace() != _sage_const_0 
assert p.is_irreducible()

coeffs = [coeff.integer_representation() for coeff in list(p)]
print(f" -> {coeffs}")

F2t16 = R.quotient_ring(R.ideal(p), names=('r16',)); (r16,) = F2t16._first_ngens(1)
R = PolynomialRing(F2t16, names=('X',)); (X,) = R._first_ngens(1)

# Step 3
a = z8**_sage_const_5  * r16
p = X**_sage_const_2  + X + a
assert trace(a) != _sage_const_0 
#assert p.is_irreducible()

F2t32 = R.quotient_ring(R.ideal(p), names=('r32',)); (r32,) = F2t32._first_ngens(1)
R = PolynomialRing(F2t32, names=('X',)); (X,) = R._first_ngens(1)

if False:
    a = z8**_sage_const_5  * r16 * r32
    p = X**_sage_const_2  + X + a
    assert trace(a) != _sage_const_0 

    F2t64 = R.quotient_ring(R.ideal(p), names=('r64',)); (r64,) = F2t64._first_ngens(1)
    R = PolynomialRing(F2t64, names=('X',)); (X,) = R._first_ngens(1)

    for _ in range(_sage_const_10 ):
        t1 = F2t64.random_element()
        t2 = F2t64.random_element()
        res = t1*t2
        print(to_numerical(t1), to_numerical(t2), to_numerical(res))

else:
    a = z8**_sage_const_4  * r16 * r32
    p = X**_sage_const_3  - a
    assert is_valid(_sage_const_2 **_sage_const_32 , a, _sage_const_3 )
    print('Good')

    F2t96 = R.quotient_ring(R.ideal(p), names=('r96',)); (r96,) = F2t96._first_ngens(1)
    R = PolynomialRing(F2t96, names=('X',)); (X,) = R._first_ngens(1)

